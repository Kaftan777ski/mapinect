#include "Constants.h"

#include "Feature.h"
#include "ofxXmlSettings.h"
#include "utils.h"

#define PCM_CONFIG			"PCMConfig:"

namespace mapinect
{

	const float			kVoxelDensityMultiplier = 2.0f / (float)KINECT_DEFAULT_WIDTH;

	int					Constants::CLOUD_STRIDE_H							= 2;
	int					Constants::CLOUD_STRIDE_V							= 1;

	int					Constants::CLOUD_POINTS_MAX							= KINECT_DEFAULT_WIDTH * KINECT_DEFAULT_HEIGHT;
	float				Constants::CLOUD_DENSITY							= 0.2f;
	float				Constants::CLOUD_VOXEL_SIZE							= 0.01f;
	float				Constants::CLOUD_Z_MAX								= 1.0;

	int					Constants::CLOUD_POINTS								= CLOUD_POINTS_MAX * CLOUD_DENSITY;

	float				Constants::TABLE_CLUSTER_MIN_PERCENT				= 0.02f;
	float				Constants::TABLE_CLUSTER_TOLERANCE_FACTOR			= 4.0f;
	float				Constants::TABLE_HEIGHT_TOLERANCE_FACTOR			= 2.0f;

	float				Constants::OBJECT_CLUSTER_MIN_PERCENT				= 0.005f;
	float				Constants::OBJECT_CLUSTER_TOLERANCE_FACTOR			= 4.0f;
	float				Constants::OBJECT_PLANE_TOLERANCE_FACTOR			= 0.5f;

	int					Constants::OBJECT_FRAMES_TO_ACCEPT					= 4;
	int					Constants::OBJECT_INVALID_FRAMES_TO_RESET			= 20;
	int					Constants::OBJECT_INVALID_FRAMES_TO_DELETE			= 60;
	int					Constants::OBJECT_VOLUME_TOLERANCE					= 0.4;

	int					Constants::OBJECT_LOD_MAX							= 3;
	float				Constants::OBJECT_VERTEX_UNIFYING_DISTANCE_FACTOR	= 2.0f;
	float				Constants::OBJECT_CLOUD_DIFF_PERCENT				= 0.05f;
	float				Constants::OBJECT_RECALCULATE_TOLERANCE_FACTOR		= 2.0f;
	float				Constants::OBJECT_TRANSLATION_TOLERANCE_FACTOR		= 2.0f;

	int					Constants::TOUCH_FRAMES_TO_DISCARD					= 3;
	float				Constants::TOUCH_DISTANCE_FACTOR					= 1.0f;
	float				Constants::TOUCH_TOLERANCE_FACTOR					= 1.0f;
	float				Constants::TOUCH_CLUSTER_MIN_PERCENT				= 0.04f;
	float				Constants::TOUCH_TRANSLATION_TOLERANCE_FACTOR		= 4.0f;
	int					Constants::TOUCH_MAX_PER_FACE						= 4;

	//contsantes de view field
	float				Constants::FRUSTUM_NEAR_DISTANCE					= 0.2;
	float				Constants::FRUSTUM_FOV_HORIZONTAL					= 57.0f;
	float				Constants::FRUSTUM_FOV_VERTICAL						= 43.0f;	
	float				Constants::FRUSTUM_WFAR_2							= tan(ofDegToRad(FRUSTUM_FOV_HORIZONTAL / 2.0f)) * CLOUD_Z_MAX; 
	float				Constants::FRUSTUM_HFAR_2							= tan(ofDegToRad(FRUSTUM_FOV_VERTICAL / 2.0f)) * CLOUD_Z_MAX;
	float				Constants::FRUSTUM_WNEAR_2							= tan(ofDegToRad(FRUSTUM_FOV_HORIZONTAL / 2.0f)) * FRUSTUM_NEAR_DISTANCE; 
	float				Constants::FRUSTUM_HNEAR_2							= tan(ofDegToRad(FRUSTUM_FOV_VERTICAL / 2.0f)) * FRUSTUM_NEAR_DISTANCE;

	// Para la calibración inicial de la mesa
	int					Constants::TABLE_VERTEX_ESTIMATED_PIXEL_TOLERANCE	= 20;
	float				Constants::TABLE_LENGTH_AB							= 0.3;
	float				Constants::TABLE_LENGTH_AD							= 0.3;

	void Constants::LoadConstants()
	{
		ofxXmlSettings XML;
		if(XML.loadFile("PCM_Config.xml"))
		{
			CLOUD_STRIDE_H							= XML.getValue(PCM_CONFIG "CLOUD_STRIDE_H", CLOUD_STRIDE_H);
			CLOUD_STRIDE_V							= XML.getValue(PCM_CONFIG "CLOUD_STRIDE_V", CLOUD_STRIDE_V);

			CLOUD_DENSITY							= XML.getValue(PCM_CONFIG "CLOUD_DENSITY", CLOUD_DENSITY);
			CLOUD_VOXEL_SIZE						= XML.getValue(PCM_CONFIG "CLOUD_VOXEL_SIZE", CLOUD_VOXEL_SIZE);

			if (IsFeatureUniformDensityActive())
			{
				CLOUD_DENSITY = round(kVoxelDensityMultiplier / CLOUD_VOXEL_SIZE, 3);
			}
			else
			{
				CLOUD_VOXEL_SIZE = round(kVoxelDensityMultiplier / CLOUD_DENSITY, 3);
			}

			CLOUD_Z_MAX								= XML.getValue(PCM_CONFIG "CLOUD_Z_MAX", CLOUD_Z_MAX);

			CLOUD_POINTS							= CLOUD_POINTS_MAX * CLOUD_DENSITY;

			TABLE_CLUSTER_MIN_PERCENT				= XML.getValue(PCM_CONFIG "TABLE_CLUSTER_MIN_PERCENT", TABLE_CLUSTER_MIN_PERCENT);
			TABLE_CLUSTER_TOLERANCE_FACTOR			= XML.getValue(PCM_CONFIG "TABLE_CLUSTER_TOLERANCE_FACTOR", TABLE_CLUSTER_TOLERANCE_FACTOR);
			TABLE_HEIGHT_TOLERANCE_FACTOR			= XML.getValue(PCM_CONFIG "TABLE_HEIGHT_TOLERANCE_FACTOR", TABLE_HEIGHT_TOLERANCE_FACTOR);

			OBJECT_CLUSTER_MIN_PERCENT				= XML.getValue(PCM_CONFIG "OBJECT_CLUSTER_MIN_PERCENT", OBJECT_CLUSTER_MIN_PERCENT);
			OBJECT_CLUSTER_TOLERANCE_FACTOR			= XML.getValue(PCM_CONFIG "OBJECT_CLUSTER_TOLERANCE_FACTOR", OBJECT_CLUSTER_TOLERANCE_FACTOR);
			OBJECT_PLANE_TOLERANCE_FACTOR			= XML.getValue(PCM_CONFIG "OBJECT_PLANE_TOLERANCE_FACTOR", OBJECT_PLANE_TOLERANCE_FACTOR);

			OBJECT_FRAMES_TO_ACCEPT					= XML.getValue(PCM_CONFIG "OBJECT_FRAMES_TO_ACCEPT", OBJECT_FRAMES_TO_ACCEPT);
			OBJECT_INVALID_FRAMES_TO_RESET			= XML.getValue(PCM_CONFIG "OBJECT_INVALID_FRAMES_TO_RESET", OBJECT_INVALID_FRAMES_TO_RESET);
			OBJECT_INVALID_FRAMES_TO_DELETE			= XML.getValue(PCM_CONFIG "OBJECT_INVALID_FRAMES_TO_DELETE", OBJECT_INVALID_FRAMES_TO_DELETE);
			OBJECT_VOLUME_TOLERANCE					= XML.getValue(PCM_CONFIG "OBJECT_VOLUME_TOLERANCE", OBJECT_VOLUME_TOLERANCE);
			OBJECT_LOD_MAX							= XML.getValue(PCM_CONFIG "OBJECT_LOD_MAX", OBJECT_LOD_MAX);
			OBJECT_VERTEX_UNIFYING_DISTANCE_FACTOR	= XML.getValue(PCM_CONFIG "OBJECT_VERTEX_UNIFYING_DISTANCE_FACTOR", OBJECT_VERTEX_UNIFYING_DISTANCE_FACTOR);
			OBJECT_CLOUD_DIFF_PERCENT				= XML.getValue(PCM_CONFIG "OBJECT_CLOUD_DIFF_PERCENT", OBJECT_CLOUD_DIFF_PERCENT);
			OBJECT_RECALCULATE_TOLERANCE_FACTOR		= XML.getValue(PCM_CONFIG "OBJECT_RECALCULATE_TOLERANCE_FACTOR", OBJECT_RECALCULATE_TOLERANCE_FACTOR);
			OBJECT_TRANSLATION_TOLERANCE_FACTOR		= XML.getValue(PCM_CONFIG "OBJECT_TRANSLATION_TOLERANCE_FACTOR", OBJECT_TRANSLATION_TOLERANCE_FACTOR);
			
			TOUCH_FRAMES_TO_DISCARD					= XML.getValue(PCM_CONFIG "TOUCH_FRAMES_TO_DISCARD", TOUCH_FRAMES_TO_DISCARD);
			TOUCH_DISTANCE_FACTOR					= XML.getValue(PCM_CONFIG "TOUCH_DISTANCE_FACTOR", TOUCH_DISTANCE_FACTOR);
			TOUCH_TOLERANCE_FACTOR					= XML.getValue(PCM_CONFIG "TOUCH_TOLERANCE_FACTOR", TOUCH_TOLERANCE_FACTOR);
			TOUCH_CLUSTER_MIN_PERCENT				= XML.getValue(PCM_CONFIG "TOUCH_CLUSTER_MIN_PERCENT", TOUCH_CLUSTER_MIN_PERCENT);
			TOUCH_TRANSLATION_TOLERANCE_FACTOR		= XML.getValue(PCM_CONFIG "TOUCH_TRANSLATION_TOLERANCE_FACTOR", TOUCH_TRANSLATION_TOLERANCE_FACTOR);
			TOUCH_MAX_PER_FACE						= XML.getValue(PCM_CONFIG "TOUCH_MAX_PER_FACE", TOUCH_MAX_PER_FACE);

			// Para el IsInViewField
			FRUSTUM_NEAR_DISTANCE					= XML.getValue(PCM_CONFIG "FRUSTUM_NEAR_DISTANCE",0.2);
			FRUSTUM_FOV_HORIZONTAL					= XML.getValue(PCM_CONFIG "FRUSTUM_FOV_HORIZONTAL",64.0f);
			FRUSTUM_FOV_VERTICAL					= XML.getValue(PCM_CONFIG "FRUSTUM_FOV_VERTICAL",63.0f);
			FRUSTUM_WFAR_2							= tan(ofDegToRad(FRUSTUM_FOV_HORIZONTAL / 2.0f)) * CLOUD_Z_MAX; 
			FRUSTUM_HFAR_2							= tan(ofDegToRad(FRUSTUM_FOV_VERTICAL / 2.0f)) * CLOUD_Z_MAX;
			FRUSTUM_WNEAR_2							= tan(ofDegToRad(FRUSTUM_FOV_HORIZONTAL / 2.0f)) * FRUSTUM_NEAR_DISTANCE; 
			FRUSTUM_HNEAR_2							= tan(ofDegToRad(FRUSTUM_FOV_VERTICAL / 2.0f)) * FRUSTUM_NEAR_DISTANCE;

			// Para la calibración inicial de la mesa
			TABLE_VERTEX_ESTIMATED_PIXEL_TOLERANCE	= XML.getValue(PCM_CONFIG "TABLE_VERTEX_ESTIMATED_PIXEL_TOLERANCE", TABLE_VERTEX_ESTIMATED_PIXEL_TOLERANCE);
			TABLE_LENGTH_AB							= XML.getValue(PCM_CONFIG "TABLE_LENGTH_AB", TABLE_LENGTH_AB);
			TABLE_LENGTH_AD							= XML.getValue(PCM_CONFIG "TABLE_LENGTH_AD", TABLE_LENGTH_AD);

		}
	}

	int Constants::CLOUD_STRIDE()
	{
		return ceil(1.0f / CLOUD_DENSITY);
	}

	float Constants::CLOUD_VOXEL_SIZE_FOR_STRIDE(int stride)
	{
		return round(kVoxelDensityMultiplier * (float)stride, 3);
	}

	int Constants::TABLE_CLUSTER_MIN_SIZE()
	{
		return CLOUD_POINTS * TABLE_CLUSTER_MIN_PERCENT;
	}

	float Constants::TABLE_CLUSTER_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * TABLE_CLUSTER_TOLERANCE_FACTOR;
	}

	float Constants::TABLE_HEIGHT_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * TABLE_HEIGHT_TOLERANCE_FACTOR;
	}

	int Constants::OBJECT_CLUSTER_MIN_SIZE()
	{
		return CLOUD_POINTS * OBJECT_CLUSTER_MIN_PERCENT;
	}

	float Constants::OBJECT_CLUSTER_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * OBJECT_CLUSTER_TOLERANCE_FACTOR;
	}

	float Constants::OBJECT_PLANE_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * OBJECT_PLANE_TOLERANCE_FACTOR;
	}

	float Constants::OBJECT_VERTEX_UNIFYING_DISTANCE()
	{
		return CLOUD_VOXEL_SIZE * OBJECT_VERTEX_UNIFYING_DISTANCE_FACTOR;
	}

	float Constants::OBJECT_RECALCULATE_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * OBJECT_RECALCULATE_TOLERANCE_FACTOR;
	}

	float Constants::OBJECT_TRANSLATION_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * OBJECT_TRANSLATION_TOLERANCE_FACTOR;
	}

	float Constants::TOUCH_DISTANCE()
	{
		return CLOUD_VOXEL_SIZE * TOUCH_DISTANCE_FACTOR;
	}

	float Constants::TOUCH_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * TOUCH_TOLERANCE_FACTOR;
	}

	int Constants::TOUCH_CLUSTER_MIN_SIZE()
	{
		return CLOUD_POINTS * TOUCH_CLUSTER_MIN_PERCENT;
	}

	float Constants::TOUCH_TRANSLATION_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * TOUCH_TRANSLATION_TOLERANCE_FACTOR;
	}
}