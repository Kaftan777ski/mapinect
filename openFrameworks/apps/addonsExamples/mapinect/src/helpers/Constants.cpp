#include "Constants.h"

#include "Feature.h"
#include "ofxXmlSettings.h"
#include "utils.h"

#define PCM_CONFIG			"PCMConfig:"

namespace mapinect
{

	const float			kVoxelDensityMultiplier = 2.0f / (float)KINECT_DEFAULT_WIDTH;

	int					Constants::CLOUD_STRIDE_H							= 2;
	int					Constants::CLOUD_STRIDE_V							= 1;

	int					Constants::CLOUD_POINTS_MAX							= KINECT_DEFAULT_WIDTH * KINECT_DEFAULT_HEIGHT;
	float				Constants::CLOUD_DENSITY							= 0.2f;
	float				Constants::CLOUD_VOXEL_SIZE							= 0.01f;
	float				Constants::CLOUD_Z_MAX								= 0.8;//2.0f;

	int					Constants::CLOUD_POINTS								= CLOUD_POINTS_MAX * CLOUD_DENSITY;

	float				Constants::TABLE_CLUSTER_MIN_PERCENT				= 0.02f;
	float				Constants::TABLE_CLUSTER_TOLERANCE_FACTOR			= 4.0f;
	float				Constants::TABLE_HEIGHT_TOLERANCE_FACTOR			= 2.0f;

	float				Constants::OBJECT_CLUSTER_MIN_PERCENT				= 0.005f;
	float				Constants::OBJECT_CLUSTER_TOLERANCE_FACTOR			= 4.0f;

	int					Constants::OBJECT_FRAMES_TO_ACCEPT					= 4;
	int					Constants::OBJECT_INVALID_FRAMES_TO_RESET			= 20;
	int					Constants::OBJECT_INVALID_FRAMES_TO_DELETE			= 60;
	int					Constants::OBJECT_VOLUME_TOLERANCE					= 0.4;

	int					Constants::OBJECT_LOD_MAX							= 3;
	float				Constants::OBJECT_VERTEX_UNIFYING_DISTANCE_FACTOR	= 2.0f;
	float				Constants::OBJECT_CLOUD_DIFF_PERCENT				= 0.05f;
	float				Constants::OBJECT_RECALCULATE_TOLERANCE_FACTOR		= 2.0f;
	float				Constants::OBJECT_TRANSLATION_TOLERANCE_FACTOR		= 2.0f;

	int					Constants::TOUCH_FRAMES_TO_DISCARD					= 3;
	float				Constants::TOUCH_DISTANCE_FACTOR					= 1.0f;
	float				Constants::TOUCH_TOLERANCE_FACTOR					= 1.0f;
	float				Constants::TOUCH_CLUSTER_MIN_PERCENT				= 0.04f;
	float				Constants::TOUCH_TRANSLATION_TOLERANCE_FACTOR		= 4.0f;
	int					Constants::TOUCH_MAX_PER_FACE						= 4;

	//contsantes de view field
	float				Constants::NDISTANCE								= 0.2;
	float				Constants::FOV_HORIZONTAL							= 57.0f;
	float				Constants::FOV_VERTICAL								= 43.0f;	
	float				Constants::WFAR_2									= tan(ofDegToRad(FOV_HORIZONTAL / 2.0f)) * CLOUD_Z_MAX; 
	float				Constants::WFAR										= WFAR_2 * 2;
	float				Constants::HFAR_2									= tan(ofDegToRad(FOV_VERTICAL / 2.0f)) * CLOUD_Z_MAX;
	float				Constants::HFAR										= HFAR_2 * 2;
	float				Constants::WNEAR_2									= tan(ofDegToRad(FOV_HORIZONTAL / 2.0f)) * NDISTANCE; 
	float				Constants::WNEAR									= WNEAR_2 * 2;
	float				Constants::HNEAR_2									= tan(ofDegToRad(FOV_VERTICAL / 2.0f)) * NDISTANCE;
	float				Constants::HNEAR									= HNEAR_2 * 2;
	float				Constants::FOV_MIN_DIST_CENTROID					= 0.1;

	// Para la calibración inicial de la mesa
	int					Constants::PIXEL_TOLERANCE_ESTIMATED_VERTEX			= 40;
	float				Constants::TABLE_LENGTH_AB							= 0.3;
	float				Constants::TABLE_LENGTH_AD							= 0.3;

	void Constants::LoadConstants()
	{
		ofxXmlSettings XML;
		if(XML.loadFile("PCM_Config.xml"))
		{
			CLOUD_STRIDE_H							= XML.getValue(PCM_CONFIG "CLOUD_STRIDE_H", CLOUD_STRIDE_H);
			CLOUD_STRIDE_V							= XML.getValue(PCM_CONFIG "CLOUD_STRIDE_V", CLOUD_STRIDE_V);

			CLOUD_DENSITY							= XML.getValue(PCM_CONFIG "CLOUD_DENSITY", CLOUD_DENSITY);
			CLOUD_VOXEL_SIZE						= XML.getValue(PCM_CONFIG "CLOUD_VOXEL_SIZE", CLOUD_VOXEL_SIZE);

			if (IsFeatureUniformDensity())
			{
				CLOUD_DENSITY = round(kVoxelDensityMultiplier / CLOUD_VOXEL_SIZE, 3);
			}
			else
			{
				CLOUD_VOXEL_SIZE = round(kVoxelDensityMultiplier / CLOUD_DENSITY, 3);
			}

			CLOUD_Z_MAX								= XML.getValue(PCM_CONFIG "CLOUD_Z_MAX", CLOUD_Z_MAX);

			CLOUD_POINTS							= CLOUD_POINTS_MAX * CLOUD_DENSITY;

			TABLE_CLUSTER_MIN_PERCENT				= XML.getValue(PCM_CONFIG "TABLE_CLUSTER_MIN_PERCENT", TABLE_CLUSTER_MIN_PERCENT);
			TABLE_CLUSTER_TOLERANCE_FACTOR			= XML.getValue(PCM_CONFIG "TABLE_CLUSTER_TOLERANCE_FACTOR", TABLE_CLUSTER_TOLERANCE_FACTOR);
			TABLE_HEIGHT_TOLERANCE_FACTOR			= XML.getValue(PCM_CONFIG "TABLE_HEIGHT_TOLERANCE_FACTOR", TABLE_HEIGHT_TOLERANCE_FACTOR);

			OBJECT_CLUSTER_MIN_PERCENT				= XML.getValue(PCM_CONFIG "OBJECT_CLUSTER_MIN_PERCENT", OBJECT_CLUSTER_MIN_PERCENT);
			OBJECT_CLUSTER_TOLERANCE_FACTOR			= XML.getValue(PCM_CONFIG "OBJECT_CLUSTER_TOLERANCE_FACTOR", OBJECT_CLUSTER_TOLERANCE_FACTOR);

			OBJECT_FRAMES_TO_ACCEPT					= XML.getValue(PCM_CONFIG "OBJECT_FRAMES_TO_ACCEPT", OBJECT_FRAMES_TO_ACCEPT);
			OBJECT_INVALID_FRAMES_TO_RESET			= XML.getValue(PCM_CONFIG "OBJECT_INVALID_FRAMES_TO_RESET", OBJECT_INVALID_FRAMES_TO_RESET);
			OBJECT_INVALID_FRAMES_TO_DELETE			= XML.getValue(PCM_CONFIG "OBJECT_INVALID_FRAMES_TO_DELETE", OBJECT_INVALID_FRAMES_TO_DELETE);
			OBJECT_VOLUME_TOLERANCE					= XML.getValue(PCM_CONFIG "OBJECT_VOLUME_TOLERANCE", OBJECT_VOLUME_TOLERANCE);
			OBJECT_LOD_MAX							= XML.getValue(PCM_CONFIG "OBJECT_LOD_MAX", OBJECT_LOD_MAX);
			OBJECT_VERTEX_UNIFYING_DISTANCE_FACTOR	= XML.getValue(PCM_CONFIG "OBJECT_VERTEX_UNIFYING_DISTANCE_FACTOR", OBJECT_VERTEX_UNIFYING_DISTANCE_FACTOR);
			OBJECT_CLOUD_DIFF_PERCENT				= XML.getValue(PCM_CONFIG "OBJECT_CLOUD_DIFF_PERCENT", OBJECT_CLOUD_DIFF_PERCENT);
			OBJECT_RECALCULATE_TOLERANCE_FACTOR		= XML.getValue(PCM_CONFIG "OBJECT_RECALCULATE_TOLERANCE_FACTOR", OBJECT_RECALCULATE_TOLERANCE_FACTOR);
			OBJECT_TRANSLATION_TOLERANCE_FACTOR		= XML.getValue(PCM_CONFIG "OBJECT_TRANSLATION_TOLERANCE_FACTOR", OBJECT_TRANSLATION_TOLERANCE_FACTOR);
			
			TOUCH_FRAMES_TO_DISCARD					= XML.getValue(PCM_CONFIG "TOUCH_FRAMES_TO_DISCARD", TOUCH_FRAMES_TO_DISCARD);
			TOUCH_DISTANCE_FACTOR					= XML.getValue(PCM_CONFIG "TOUCH_DISTANCE_FACTOR", TOUCH_DISTANCE_FACTOR);
			TOUCH_TOLERANCE_FACTOR					= XML.getValue(PCM_CONFIG "TOUCH_TOLERANCE_FACTOR", TOUCH_TOLERANCE_FACTOR);
			TOUCH_CLUSTER_MIN_PERCENT				= XML.getValue(PCM_CONFIG "TOUCH_CLUSTER_MIN_PERCENT", TOUCH_CLUSTER_MIN_PERCENT);
			TOUCH_TRANSLATION_TOLERANCE_FACTOR		= XML.getValue(PCM_CONFIG "TOUCH_TRANSLATION_TOLERANCE_FACTOR", TOUCH_TRANSLATION_TOLERANCE_FACTOR);
			TOUCH_MAX_PER_FACE						= XML.getValue(PCM_CONFIG "TOUCH_MAX_PER_FACE", TOUCH_MAX_PER_FACE);

			// Para el IsInViewField
			NDISTANCE								= XML.getValue(PCM_CONFIG "NDISTANCE",0.2);
			FOV_HORIZONTAL							= XML.getValue(PCM_CONFIG "FOV_HORIZONTAL",57.0f);
			FOV_VERTICAL							= XML.getValue(PCM_CONFIG "FOV_VERTICAL",43.0f);
			FOV_MIN_DIST_CENTROID					= XML.getValue(PCM_CONFIG "FOV_MIN_DIST_CENTROID",0.1f);
			WFAR_2									= tan(ofDegToRad(FOV_HORIZONTAL / 2.0f)) * CLOUD_Z_MAX; 
			WFAR									= WFAR_2 * 2;
			HFAR_2									= tan(ofDegToRad(FOV_VERTICAL / 2.0f)) * CLOUD_Z_MAX;
			HFAR									= HFAR_2 * 2;
			WNEAR_2									= tan(ofDegToRad(FOV_HORIZONTAL / 2.0f)) * NDISTANCE; 
			WNEAR									= WNEAR_2 * 2;
			HNEAR_2									= tan(ofDegToRad(FOV_VERTICAL / 2.0f)) * NDISTANCE;
			HNEAR									= HNEAR_2 * 2;

			// Para la calibración inicial de la mesa
			PIXEL_TOLERANCE_ESTIMATED_VERTEX		= XML.getValue(PCM_CONFIG "PIXEL_TOLERANCE_ESTIMATED_VERTEX", PIXEL_TOLERANCE_ESTIMATED_VERTEX);
			TABLE_LENGTH_AB							= XML.getValue(PCM_CONFIG "TABLE_LENGTH_AB", TABLE_LENGTH_AB);
			TABLE_LENGTH_AD							= XML.getValue(PCM_CONFIG "TABLE_LENGTH_AD", TABLE_LENGTH_AD);

		}
	}

	int Constants::CLOUD_STRIDE()
	{
		return ceil(1.0f / CLOUD_DENSITY);
	}

	float Constants::CLOUD_VOXEL_SIZE_FOR_STRIDE(int stride)
	{
		return round(kVoxelDensityMultiplier * (float)stride, 3);
	}

	int Constants::TABLE_CLUSTER_MIN_SIZE()
	{
		return CLOUD_POINTS * TABLE_CLUSTER_MIN_PERCENT;
	}

	float Constants::TABLE_CLUSTER_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * TABLE_CLUSTER_TOLERANCE_FACTOR;
	}

	float Constants::TABLE_HEIGHT_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * TABLE_HEIGHT_TOLERANCE_FACTOR;
	}

	int Constants::OBJECT_CLUSTER_MIN_SIZE()
	{
		return CLOUD_POINTS * OBJECT_CLUSTER_MIN_PERCENT;
	}

	float Constants::OBJECT_CLUSTER_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * OBJECT_CLUSTER_TOLERANCE_FACTOR;
	}

	float Constants::OBJECT_VERTEX_UNIFYING_DISTANCE()
	{
		return CLOUD_VOXEL_SIZE * OBJECT_VERTEX_UNIFYING_DISTANCE_FACTOR;
	}

	float Constants::OBJECT_RECALCULATE_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * OBJECT_RECALCULATE_TOLERANCE_FACTOR;
	}

	float Constants::OBJECT_TRANSLATION_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * OBJECT_TRANSLATION_TOLERANCE_FACTOR;
	}

	float Constants::TOUCH_DISTANCE()
	{
		return CLOUD_VOXEL_SIZE * TOUCH_DISTANCE_FACTOR;
	}

	float Constants::TOUCH_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * TOUCH_TOLERANCE_FACTOR;
	}

	int Constants::TOUCH_CLUSTER_MIN_SIZE()
	{
		return CLOUD_POINTS * TOUCH_CLUSTER_MIN_PERCENT;
	}

	float Constants::TOUCH_TRANSLATION_TOLERANCE()
	{
		return CLOUD_VOXEL_SIZE * TOUCH_TRANSLATION_TOLERANCE_FACTOR;
	}
}